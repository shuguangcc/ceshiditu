import{r as m,t as b}from"./typedArrayUtil-a8b5b3e9.js";import{s as _,a as p}from"./Error-653283ae.js";let x=class{};function f(o,...e){let r="";for(let t=0;t<e.length;t++)r+=o[t]+e[t];return r+=o[o.length-1],r}(function(o){function e(t){return Math.round(t).toString()}function r(t){return t.toPrecision(8)}o.int=e,o.float=r})(f||(f={}));var d;(function(o){o[o.Pass=0]="Pass",o[o.Draw=1]="Draw"})(d||(d={}));let k=class{constructor(e,r,t,s,i=null){this.name=e,this.type=r,this.arraySize=i,this.bind={[d.Pass]:null,[d.Draw]:null},m(t)&&m(s)&&(this.bind[t]=s)}equals(e){return this.type===e.type&&this.name===e.name&&this.arraySize===e.arraySize}};const g=_.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder");class ${constructor(){this._includedModules=new Map}include(e,r){if(this._includedModules.has(e)){const t=this._includedModules.get(e);if(t!==r){g.error("Trying to include shader module multiple times with different sets of options.");const s=new Set;for(const i of Object.keys(t))t[i]!==e[i]&&s.add(i);for(const i of Object.keys(e))t[i]!==e[i]&&s.add(i);s.forEach(i=>console.error(`  ${i}: current ${t[i]} new ${e[i]}`))}}else this._includedModules.set(e,r),e(this.builder,r)}}class R extends ${constructor(){super(...arguments),this.vertex=new S,this.fragment=new S,this.attributes=new w,this.varyings=new v,this.extensions=new c,this.constants=new n}get fragmentUniforms(){return this.fragment.uniforms.entries}get builder(){return this}generate(e){const r=this.extensions.generateSource(e),t=this.attributes.generateSource(e),s=this.varyings.generateSource(),i=e==="vertex"?this.vertex:this.fragment,a=i.uniforms.generateSource(),u=i.code.generateSource(),l=e==="vertex"?A:I,h=this.constants.generateSource().concat(i.constants.generateSource());return`
${r.join(`
`)}

${l}

${h.join(`
`)}

${a.join(`
`)}

${t.join(`
`)}

${s.join(`
`)}

${u.join(`
`)}`}generateBind(e,r){const t=new Map;this.vertex.uniforms.entries.forEach(a=>{const u=a.bind[e];m(u)&&t.set(a.name,u)}),this.fragment.uniforms.entries.forEach(a=>{const u=a.bind[e];m(u)&&t.set(a.name,u)});const s=Array.from(t.values()),i=s.length;return(a,u,l)=>{for(let h=0;h<i;++h)s[h](r,a,u,l)}}}class T{constructor(){this._entries=new Map}add(e){if(!Array.isArray(e))return this._add(e);for(const r of e)this._add(r)}get(e){return this._entries.get(e)}_add(e){if(b(e))g.error(`Trying to add null Uniform from ${new Error().stack}.`);else{if(this._entries.has(e.name)&&!this._entries.get(e.name).equals(e))throw new p(`Duplicate uniform name ${e.name} for different uniform type`);this._entries.set(e.name,e)}}generateSource(){return Array.from(this._entries.values()).map(e=>m(e.arraySize)?`uniform ${e.type} ${e.name}[${e.arraySize}];`:`uniform ${e.type} ${e.name};`)}get entries(){return Array.from(this._entries.values())}}class y{constructor(){this._entries=new Array}add(e){this._entries.push(e)}generateSource(){return this._entries}}class S extends ${constructor(){super(...arguments),this.uniforms=new T,this.code=new y,this.constants=new n}get builder(){return this}}class w{constructor(){this._entries=new Array}add(e,r){this._entries.push([e,r])}generateSource(e){return e==="fragment"?[]:this._entries.map(r=>`attribute ${r[1]} ${r[0]};`)}}class v{constructor(){this._entries=new Array}add(e,r){this._entries.push([e,r])}generateSource(){return this._entries.map(e=>`varying ${e[1]} ${e[0]};`)}}class c{constructor(){this._entries=new Set}add(e){this._entries.add(e)}generateSource(e){const r=e==="vertex"?c.ALLOWLIST_VERTEX:c.ALLOWLIST_FRAGMENT;return Array.from(this._entries).filter(t=>r.includes(t)).map(t=>`#extension ${t} : enable`)}}c.ALLOWLIST_FRAGMENT=["GL_EXT_shader_texture_lod","GL_OES_standard_derivatives"],c.ALLOWLIST_VERTEX=[];class n{constructor(){this._entries=new Set}add(e,r,t){let s="ERROR_CONSTRUCTOR_STRING";switch(r){case"float":s=n._numberToFloatStr(t);break;case"int":s=n._numberToIntStr(t);break;case"bool":s=t.toString();break;case"vec2":s=`vec2(${n._numberToFloatStr(t[0])},                            ${n._numberToFloatStr(t[1])})`;break;case"vec3":s=`vec3(${n._numberToFloatStr(t[0])},                            ${n._numberToFloatStr(t[1])},                            ${n._numberToFloatStr(t[2])})`;break;case"vec4":s=`vec4(${n._numberToFloatStr(t[0])},                            ${n._numberToFloatStr(t[1])},                            ${n._numberToFloatStr(t[2])},                            ${n._numberToFloatStr(t[3])})`;break;case"ivec2":s=`ivec2(${n._numberToIntStr(t[0])},                             ${n._numberToIntStr(t[1])})`;break;case"ivec3":s=`ivec3(${n._numberToIntStr(t[0])},                             ${n._numberToIntStr(t[1])},                             ${n._numberToIntStr(t[2])})`;break;case"ivec4":s=`ivec4(${n._numberToIntStr(t[0])},                             ${n._numberToIntStr(t[1])},                             ${n._numberToIntStr(t[2])},                             ${n._numberToIntStr(t[3])})`;break;case"mat2":case"mat3":case"mat4":s=`${r}(${Array.prototype.map.call(t,i=>n._numberToFloatStr(i)).join(", ")})`}return this._entries.add(`const ${r} ${e} = ${s};`),this}static _numberToIntStr(e){return e.toFixed(0)}static _numberToFloatStr(e){return Number.isInteger(e)?e.toFixed(1):e.toString()}generateSource(){return Array.from(this._entries)}}const I=`#ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
  precision highp sampler2D;
#else
  precision mediump float;
  precision mediump sampler2D;
#endif`,A=`precision highp float;
precision highp sampler2D;`;export{d as a,k as i,f as n,R as o,x as t};
