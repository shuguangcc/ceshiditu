import{y as G}from"./string-cdf077e6.js";import{r as R,t as v,i as x}from"./typedArrayUtil-a8b5b3e9.js";import{n as T}from"./FeatureLikeLayerView3D-e095b99c.js";import{T as $,v as z,W as B,j as K}from"./fieldUtils-31bfecd2.js";import{e as l,n as A,y as u,I as J,m as Q,J as W}from"./cast-7928d7aa.js";import{s as j}from"./Error-653283ae.js";import{d as H}from"./HandleOwner-e1406413.js";import"./ensureType-cf29afa9.js";import{_ as X}from"./preload-helper-41c905a7.js";import{a as Y,n as Z,u as ee}from"./DefinitionExpressionSceneLayerView-5a30c6e1.js";import{j as M}from"./reactiveUtils-f41a4e00.js";import{r as te,A as re,e as ne,t as ie}from"./projection-d7b57a6c.js";import{u as se}from"./LayerView-b83ced89.js";const oe={setAttribute(){},rollback(){},commit(){}};var I;function Ae(e,r){const t=r.attributes[e.objectIdField],n=e.sessions.get(t);if(n)return n;const a=G(r.attributes),s=new Set;if(t==null)return oe;const d=e.i3sOverrides.createInteractiveEditSession(t),i=new Map,f=(p,h)=>{const y=i.get(p);if(y==null){const m=h.indexOf(t);return i.set(p,m),m}return y};let o=I.EDITING;const g={setAttribute(p,h){if(o!==I.EDITING)return;const y=e.fieldsIndex.get(p);if(v(y))return;const m=e.attributeStorageInfo.findIndex(_=>_.name===y.name);if(m<0)return;d.set(m,h);const b=e.attributeStorageInfo[m];let E=!1;s.add(p),e.forEachNode((_,N)=>{const L=f(_,N);if(L===-1)return;const U=e.getAttributeData(_.index);if(U){const D=U[b.name];D&&(D[L]=h,e.setAttributeData(_.index,U,r),E=!0)}}),E&&e.clearMemCache()},rollback(){if(o===I.EDITING){for(const p of s)this.setAttribute(p,a[p]);d.rollback(),o=I.ROLLED_BACK,e.sessions.delete(t)}},commit(){o===I.EDITING&&(d.commit(),o=I.COMMITTED,e.sessions.delete(t))}};return e.sessions.set(t,g),g}function Ne(e,r){const t=[...r.addedFeatures,...r.updatedFeatures,...r.deletedFeatures];for(const n of t)n.objectId&&e.i3sOverrides.updateGeometry(n.objectId)}function Ue(e,r){const t=ae(e,r);if(t.size===0)return;const n=new Map;for(let s=0;s<e.attributeStorageInfo.length;s++)n.set(e.attributeStorageInfo[s].name,s);let a=!1;t.forEach((s,d)=>{const i=e.getAttributeData(d);let f=!1;s.forEach((o,g)=>{const p=R(i)?i[g]:null,h=n.get(g);for(const{featureIndex:y,value:m,featureId:b}of o)p&&(p[y]=m,f=!0,a=!0),e.i3sOverrides.updateAttributeValue(b,h,m)}),f&&e.setAttributeData(d,i,null)}),a&&e.clearMemCache()}function ae(e,r){const t=r.edits.updateFeatures;if(!t||t.length===0)return new q;const n=ue(r),a=new q,s=new Map;for(let o=0;o<e.attributeStorageInfo.length;o++)s.set(e.attributeStorageInfo[o].name,o);const d=e.fieldsIndex,i=e.objectIdField,f=t.filter(o=>{const g=T(d,o.attributes,i);return n.has(g)});return e.forEachNode((o,g)=>{const p=new Set(g);for(const h of f){const y=T(d,h.attributes,i);if(!p.has(y))continue;const m=g.indexOf(y);for(const b in h.attributes){const E=e.fieldsIndex.normalizeFieldName(b),_=le(a,o.index,E),N=h.attributes[b];_.push({featureIndex:m,featureId:y,value:N})}}}),a}function le(e,r,t){const n=de(e,r),a=n.get(t);if(a)return a;const s=new Array;return n.set(t,s),s}function de(e,r){const t=e.get(r);if(t)return t;const n=new ce;return e.set(r,n),n}function ue(e){const r=new Set;if(!e.updatedFeatures)return r;for(const t of e.updatedFeatures)t.objectId!=null&&t.error==null&&r.add(t.objectId);return r}(function(e){e[e.EDITING=0]="EDITING",e[e.ROLLED_BACK=1]="ROLLED_BACK",e[e.COMMITTED=2]="COMMITTED"})(I||(I={}));const ce=Map,q=Map;function Oe(){return{requiredFields:{type:[String],readOnly:!0},availableFields:{type:[String],readOnly:!0,get:function(){const{layer:e,layer:{fieldsIndex:r},requiredFields:t}=this;return e.outFields?$(r,[...z(r,e.outFields),...t]):$(r,t)}}}}const C=e=>{let r=class extends e{constructor(){super(...arguments),this._numUpdating=0,this._asyncUpdateState=new Map}get updating(){return this._numUpdating>0}autoUpdateAsync(t,n){return pe(a=>this._updateAsync(t,a),n)}async _updateAsync(t,n){if(!this._startAsyncUpdate(t)){try{const a=await n();this._set(t,a)}catch{j.getLogger(this.declaredClass).warn(`Async update of "${String(t)}" failed. Async update functions should not throw exceptions.`)}this._endAsyncUpdate(t)&&this._updateAsync(t,n)}}_startAsyncUpdate(t){const n=this._asyncUpdateState.get(t)??w.None;return n&w.Updating?(this._asyncUpdateState.set(t,n|w.Invalidated),!0):(++this._numUpdating,this._asyncUpdateState.set(t,n|w.Updating),!1)}_endAsyncUpdate(t){--this._numUpdating;const n=(this._asyncUpdateState.get(t)??w.None)&~w.Updating;return n&w.Invalidated?(this._asyncUpdateState.set(t,n&~w.Invalidated),!0):(this._asyncUpdateState.set(t,n),!1)}};return l([u({readOnly:!0})],r.prototype,"updating",null),l([u()],r.prototype,"_numUpdating",void 0),r=l([A("esri.core.AsyncUpdate")],r),r};var w;function pe(e,r){const t=()=>{s&&!d&&e(n)},n=()=>{if(!s||d)return r();s.clear(),d=!0;const i=W(s,r);return d=!1,i},a=()=>{s&&(s.destroy(),s=null)};let s=new J(t),d=!1;return e(n),{remove:a}}(function(e){e[e.None=0]="None",e[e.Updating=1]="Updating",e[e.Invalidated=2]="Invalidated"})(w||(w={}));let P=class extends C(Q){};P=l([A("esri.core.AsyncUpdate")],P);const k="esri.views.3d.layers.support.SceneLayerViewRequiredFields";let F=class extends C(H){constructor(e){super(e)}get requiredFields(){const{layerView:{layer:{fieldsIndex:e},definitionExpressionFields:r},rendererFields:t,labelingFields:n,viewFilterFields:a}=this;return $(e,[...x(r,[]),...x(t,[]),...x(n,[]),...x(a,[])])}initialize(){const e=this.layerView.layer;this.layer=e,this.handles.add([this.autoUpdateAsync("rendererFields",()=>{const{fieldsIndex:r,renderer:t}=this.layer;return t?O(n=>t.collectRequiredFields(n,r)):null}),this.autoUpdateAsync("labelingFields",()=>{const{layer:r}=this;return r.labelsVisible?O(t=>B(t,r)):null}),this.autoUpdateAsync("viewFilterFields",()=>{const{layer:r,filter:t}=this.layerView;return O(n=>K(n,r,t))})])}};async function O(e){const r=new Set;try{return await e(r),Array.from(r).sort()}catch(t){return j.getLogger(k).error(t),null}}l([u()],F.prototype,"layerView",void 0),l([u()],F.prototype,"layer",void 0),l([u()],F.prototype,"requiredFields",null),l([u()],F.prototype,"rendererFields",void 0),l([u()],F.prototype,"labelingFields",void 0),l([u()],F.prototype,"viewFilterFields",void 0),F=l([A(k)],F);const V="esri.views.layers.SceneLayerView",S=j.getLogger(V);let c=class extends se{constructor(){super(...arguments),this.layer=null,this.filter=null,this._geometryEngine=null,this._projectionEngineLoaded=!1}get availableFields(){return[]}get maximumNumberOfFeatures(){return 0}set maximumNumberOfFeatures(e){throw new Error("Not implemented")}get maximumNumberOfFeaturesExceeded(){return!1}get layerFilter(){return Y(this._layerFilter)}get _layerFilter(){const e=this.layer.filter;if(v(e)||e.geometries.length<1)return null;const r=this._geometryEngine;if(v(r)||!this._projectionEngineLoaded&&this._filterNeedsProjectionEngine)return Z;const t=e.geometries.getItemAt(0).spatialReference,n=e.geometries.toArray().map(i=>{try{i=r.simplify(i)}catch{return S.warnOncePerTick("Failed to simplify scene filter mask polygon. Polygon will be ignored."),null}if(i==null)return null;if(i.spatialReference.equals(t))return i;try{return te(i,t)}catch{return S.warnOncePerTick("Failed to project scene filter mask polygon. Polygon will be ignored."),null}}).filter(i=>i!=null).sort((i,f)=>i.extent.xmin-f.extent.xmin),a=new Set,s=new Array,d=new Array;for(let i of n){const f=i.extent.xmin;if(s.length=0,a.forEach(o=>{if(f>=o.extent.xmax)return d.push(o),void a.delete(o);i.extent.ymin<=o.extent.ymax&&i.extent.ymax>=o.extent.ymin&&r.intersects(i,o)&&s.push(o)}),s.length>0){s.push(i);try{i=r.union(s)}catch{S.warnOncePerTick("Failed to unify filter mask polygons. Polygon will be ignored.");continue}s.pop(),s.forEach(o=>a.delete(o))}a.add(i)}return a.forEach(i=>d.push(i)),d.length>0?{spatialRelationship:e.spatialRelationship,geometries:d}:null}get _filterNeedsProjectionEngine(){const e=this.layer.filter;if(v(e)||e.geometries.length<=1)return!1;const r=e.geometries.getItemAt(0).spatialReference;return e.geometries.some(({spatialReference:t})=>!t.equals(r)&&!re(t,r))}get layerFilterUpdating(){return ee(this._layerFilter)}initialize(){M(()=>!this._geometryEngine&&R(this.layer.filter)&&this.layer.filter.geometries.length).then(async()=>this._geometryEngine=await X(()=>import("./geometryEngine-62e3ccf4.js"),["./geometryEngine-62e3ccf4.js","./geometryEngineBase-3dd302e0.js","./hydrated-be86c8b3.js","./Extent-69509002.js","./cast-7928d7aa.js","./typedArrayUtil-a8b5b3e9.js","./string-cdf077e6.js","./Error-653283ae.js","./ensureType-cf29afa9.js","./nextTick-3ee5a785.js","./promiseUtils-6684e352.js","./Ellipsoid-89682c5e.js","./Polyline-bf268e7b.js"],import.meta.url)),this._projectionEngineLoaded=ne(),M(()=>!this._projectionEngineLoaded&&this._filterNeedsProjectionEngine).then(async()=>{await ie(),this._projectionEngineLoaded=!0})}highlight(e){throw new Error("Not implemented")}queryFeatures(e,r){throw new Error("Not implemented")}queryObjectIds(e,r){throw new Error("Not implemented")}queryFeatureCount(e,r){throw new Error("Not implemented")}createQuery(){throw new Error("Not implemented")}queryExtent(e,r){throw new Error("Not implemented")}};l([u()],c.prototype,"layer",void 0),l([u()],c.prototype,"availableFields",null),l([u()],c.prototype,"maximumNumberOfFeatures",null),l([u({readOnly:!0})],c.prototype,"maximumNumberOfFeaturesExceeded",null),l([u()],c.prototype,"filter",void 0),l([u({readOnly:!0})],c.prototype,"layerFilter",null),l([u({readOnly:!0})],c.prototype,"_layerFilter",null),l([u()],c.prototype,"_geometryEngine",void 0),l([u()],c.prototype,"_projectionEngineLoaded",void 0),l([u()],c.prototype,"_filterNeedsProjectionEngine",null),l([u()],c.prototype,"layerFilterUpdating",null),c=l([A(V)],c);const $e=c;export{$e as E,Ne as a,Oe as b,F as c,Ae as i,Ue as u};
