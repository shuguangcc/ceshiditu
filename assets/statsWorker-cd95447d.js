import"./geometry-5a216427.js";import"./Error-653283ae.js";import{e as C}from"./typedArrayUtil-a8b5b3e9.js";import{u as S}from"./screenUtils-410d12c0.js";import{H as R,b as j,w as k,k as A}from"./Extent-69509002.js";import{O as B}from"./quantizationUtils-33aba427.js";import"./fieldUtils-31bfecd2.js";import{y as O,m as q}from"./heatmapUtils-84e8c43b.js";import{c as E,x as G,m as Y,f as _,d as H,V as U,T as Z,F as J,D as K,N as L,S as Q}from"./utils-30a9a7e0.js";import{i as W}from"./arcadeOnDemand-c6d1b9f2.js";import"./ensureType-cf29afa9.js";import"./string-cdf077e6.js";import"./Polyline-bf268e7b.js";import"./cast-7928d7aa.js";import"./nextTick-3ee5a785.js";import"./promiseUtils-6684e352.js";import"./typeUtils-eb9416d0.js";import"./jsonMap-c1f958cf.js";import"./Ellipsoid-89682c5e.js";import"./jsonUtils-03c4af61.js";import"./preload-helper-41c905a7.js";import"./mathUtils-2519596a.js";import"./vec3-a020a6f6.js";import"./vec3f64-2f9cef06.js";import"./common-c186b691.js";import"./vec4-790471c0.js";import"./vec4f64-e407da96.js";import"./generateRendererUtils-a996108f.js";import"./colorRamps-3a8ac20b.js";import"./Color-a42a8267.js";import"./colorUtils-639f4d25.js";import"./enumeration-3c281341.js";import"./Symbol-fc4312a4.js";let z=null;function X(a,i,r){return a.x<0?a.x+=i:a.x>r&&(a.x-=i),a}function ii(a,i,r,o){const t=R(r)?j(r):null,l=t?Math.round((t.valid[1]-t.valid[0])/i.scale[0]):null;return a.map(n=>{const e=new k(C(n.geometry));return B(i,e,e,e.hasZ,e.hasM),n.geometry=t?X(e,l,o[0]):e,n})}function ai(a,i=18,r,o,t,l){const n=new Float64Array(t*l);i=Math.round(S(i));let e=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,m=0,f=0,d=0,p=0;const I=O(o,r);for(const{geometry:T,attributes:v}of a){const{x:c,y:u}=T,x=Math.max(0,c-i),V=Math.max(0,u-i),D=Math.min(l,u+i),g=Math.min(t,c+i),P=+I(v);for(let w=V;w<D;w++)for(let h=x;h<g;h++){const M=w*t+h,b=q(h-c,w-u,i),N=n[M];m=n[M]+=b*P;const $=m-N;f+=$,d+=$*$,m<e&&(e=m),m>s&&(s=m),p++}}if(!p)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const y=(s-e)/2;return{mean:f/p,stdDev:Math.sqrt((d-f*f/p)/p),min:e,max:s,mid:y,count:p}}async function F(a,i){if(!i)return[];const{field:r,field2:o,field3:t,fieldDelimiter:l}=a,n=a.valueExpression,e=a.normalizationType,s=a.normalizationField,m=a.normalizationTotal,f=[],d=a.viewInfoParams;let p=null,I=null;if(n){if(!z){const{arcadeUtils:v}=await W();z=v}p=z.createFunction(n),I=d&&z.getViewInfo({viewingMode:d.viewingMode,scale:d.scale,spatialReference:new A(d.spatialReference)})}const y=a.fieldInfos,T=!(i[0]&&"declaredClass"in i[0]&&i[0].declaredClass==="esri.Graphic")&&y?{fields:y}:null;return i.forEach(v=>{const c=v.attributes;let u;if(n){const x=T?{...v,layer:T}:v,V=z.createExecContext(x,I);u=z.executeFunction(p,V)}else c&&(u=c[r],o&&(u=`${E(u)}${l}${E(c[o])}`,t&&(u=`${u}${l}${E(c[t])}`)));if(e&&typeof u=="number"&&isFinite(u)){const x=c&&parseFloat(c[s]);u=G(u,e,x,m)}f.push(u)}),f}async function Ri(a){const{attribute:i,features:r}=a,{normalizationType:o,normalizationField:t,minValue:l,maxValue:n,fieldType:e}=i,s=await F({field:i.field,valueExpression:i.valueExpression,normalizationType:o,normalizationField:t,normalizationTotal:i.normalizationTotal,viewInfoParams:i.viewInfoParams,fieldInfos:i.fieldInfos},r),m=Y({normalizationType:o,normalizationField:t,minValue:l,maxValue:n}),f={value:.5,fieldType:e},d=e==="esriFieldTypeString"?_({values:s,supportsNullCount:m,percentileParams:f}):H({values:s,minValue:l,maxValue:n,useSampleStdDev:!o,supportsNullCount:m,percentileParams:f});return U(d,e==="esriFieldTypeDate")}async function ji(a){const{attribute:i,features:r}=a,o=await F({field:i.field,field2:i.field2,field3:i.field3,fieldDelimiter:i.fieldDelimiter,valueExpression:i.valueExpression,viewInfoParams:i.viewInfoParams,fieldInfos:i.fieldInfos},r),t=Z(o);return J(t,i.domains,i.returnAllCodedValues,i.fieldDelimiter)}async function ki(a){const{attribute:i,features:r}=a,{field:o,normalizationType:t,normalizationField:l,normalizationTotal:n,classificationMethod:e}=i,s=await F({field:o,valueExpression:i.valueExpression,normalizationType:t,normalizationField:l,normalizationTotal:n,viewInfoParams:i.viewInfoParams,fieldInfos:i.fieldInfos},r),m=K(s,{field:o,normalizationType:t,normalizationField:l,normalizationTotal:n,classificationMethod:e,standardDeviationInterval:i.standardDeviationInterval,numClasses:i.numClasses,minValue:i.minValue,maxValue:i.maxValue});return L(m,e)}async function Ai(a){const{attribute:i,features:r}=a,{field:o,normalizationType:t,normalizationField:l,normalizationTotal:n,classificationMethod:e}=i,s=await F({field:o,valueExpression:i.valueExpression,normalizationType:t,normalizationField:l,normalizationTotal:n,viewInfoParams:i.viewInfoParams,fieldInfos:i.fieldInfos},r);return Q(s,{field:o,normalizationType:t,normalizationField:l,normalizationTotal:n,classificationMethod:e,standardDeviationInterval:i.standardDeviationInterval,numBins:i.numBins,minValue:i.minValue,maxValue:i.maxValue})}async function Bi(a){const{attribute:i,features:r}=a,{field:o,radius:t,fieldOffset:l,transform:n,spatialReference:e,size:s}=i,m=ii(r,n,e,s),{count:f,min:d,max:p,mean:I,stdDev:y}=ai(m,t,l,o,s[0],s[1]);return{count:f,min:d,max:p,avg:I,stddev:y}}export{ki as classBreaks,Bi as heatmapStatistics,Ai as histogram,Ri as summaryStatistics,ji as uniqueValues};
