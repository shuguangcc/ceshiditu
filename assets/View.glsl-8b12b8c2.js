import{c as m}from"./mat4-44a0988f.js";import{e as u}from"./mat4f32-77b3d8ac.js";import{o as f}from"./vec3-a020a6f6.js";import{f as x,n as l}from"./vec3f64-2f9cef06.js";import{i as t,a as c}from"./ShaderBuilder-93e8045e.js";let M=class extends t{constructor(a,i){super(a,"vec3",c.Pass,(e,r,o)=>e.setUniform3fv(a,i(r,o)))}};class n extends t{constructor(a,i){super(a,"mat4",c.Pass,(e,r,o)=>e.setUniformMatrix4fv(a,i(r,o)))}}let w=class extends t{constructor(a,i){super(a,"vec3",c.Draw,(e,r,o,d)=>e.setUniform3fv(a,i(r,o,d)))}};class g extends t{constructor(a,i){super(a,"mat4",c.Draw,(e,r,o)=>e.setUniformMatrix4fv(a,i(r,o)))}}function b(s,a){a.instancedDoublePrecision?s.constants.add("cameraPosition","vec3",x):s.uniforms.add(new w("cameraPosition",(i,e)=>f(p,e.camera.viewInverseTransposeMatrix[3]-i.origin[0],e.camera.viewInverseTransposeMatrix[7]-i.origin[1],e.camera.viewInverseTransposeMatrix[11]-i.origin[2])))}function O(s,a){if(!a.instancedDoublePrecision)return void s.uniforms.add([new n("proj",(e,r)=>r.camera.projectionMatrix),new g("view",(e,r)=>m(v,r.camera.viewMatrix,e.origin)),new w("localOrigin",e=>e.origin)]);const i=e=>f(p,e.camera.viewInverseTransposeMatrix[3],e.camera.viewInverseTransposeMatrix[7],e.camera.viewInverseTransposeMatrix[11]);s.uniforms.add([new n("proj",(e,r)=>r.camera.projectionMatrix),new n("view",(e,r)=>m(v,r.camera.viewMatrix,i(r))),new M("localOrigin",(e,r)=>i(r))])}const v=u(),p=l();function N(s){s.uniforms.add(new n("viewNormal",(a,i)=>i.camera.viewInverseTransposeMatrix))}export{M as a,w as b,b as c,N as d,n as e,g as o,O as v};
