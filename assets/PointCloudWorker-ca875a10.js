import{r as u,P as A}from"./typedArrayUtil-a8b5b3e9.js";import{S}from"./quat-5b263584.js";import{e as d}from"./I3SBinaryReader-3d2c2faa.js";import{E as y}from"./vec3-a020a6f6.js";import{r as D,n as c}from"./vec3f32-c9aa289f.js";import{x as M}from"./projection-d7b57a6c.js";import{k as h}from"./Extent-69509002.js";import{c as g,a as l,f as w,m as x}from"./PointCloudWorkerUtil-e1c8092b.js";import"./mat3f64-c6305894.js";import"./quatf64-7fd38d64.js";import"./vec3f64-2f9cef06.js";import"./common-c186b691.js";import"./vec4-790471c0.js";import"./Error-653283ae.js";import"./string-cdf077e6.js";import"./VertexAttribute-9c5c630d.js";import"./preload-helper-41c905a7.js";import"./mathUtils-2519596a.js";import"./promiseUtils-6684e352.js";import"./unitUtils-47abac71.js";import"./jsonMap-c1f958cf.js";import"./Ellipsoid-89682c5e.js";import"./cast-7928d7aa.js";import"./ensureType-cf29afa9.js";import"./nextTick-3ee5a785.js";import"./SimpleObservable-7dcdef1d.js";import"./mat4-44a0988f.js";import"./Polyline-bf268e7b.js";import"./assets-0b172f07.js";import"./request-d3e98716.js";import"./aaBoundingRect-4a760199.js";import"./zscale-1e1fc911.js";import"./PointCloudUniqueValueRenderer-fed7b0dd.js";import"./enumeration-3c281341.js";import"./LegendOptions-e65e7a9c.js";import"./Color-a42a8267.js";import"./colorUtils-639f4d25.js";class z{transform(t){const o=this._transform(t),r=[o.points.buffer,o.rgb.buffer];u(o.pointIdFilterMap)&&r.push(o.pointIdFilterMap.buffer);for(const e of o.attributes)"buffer"in e.values&&A(e.values.buffer)&&e.values.buffer!==o.rgb.buffer&&r.push(e.values.buffer);return Promise.resolve({result:o,transferList:r})}_transform(t){const o=g(t.schema,t.geometryBuffer);let r=o.length/3,e=null;const n=[],m=l(t.primaryAttributeData,o,r);u(t.primaryAttributeData)&&m&&n.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:m});const a=l(t.modulationAttributeData,o,r);u(t.modulationAttributeData)&&a&&n.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:a});let f=w(t.rendererInfo,m,a,r);if(t.filterInfo&&t.filterInfo.length>0&&u(t.filterAttributesData)){const i=t.filterAttributesData.map(p=>{const v=l(p,o,r),b={attributeInfo:p.attributeInfo,values:v};return n.push(b),b});e=new Uint32Array(r),r=x(o,f,e,t.filterInfo,i)}for(const i of t.userAttributesData){const p=l(i,o,r);n.push({attributeInfo:i.attributeInfo,values:p})}3*r<f.length&&(f=new Uint8Array(f.buffer.slice(0,3*r))),this._applyElevationOffsetInPlace(o,r,t.elevationOffset);const s=this._transformCoordinates(o,r,t.obb,h.fromJSON(t.inSR),h.fromJSON(t.outSR));return{obb:t.obb,points:s,rgb:f,attributes:n,pointIdFilterMap:e}}_transformCoordinates(t,o,r,e,n){if(!M(t,e,0,t,n,0,o))throw new Error("Can't reproject");const m=D(r.center[0],r.center[1],r.center[2]),a=c(),f=c();S(I,r.quaternion);const s=new Float32Array(3*o);for(let i=0;i<o;i++)a[0]=t[3*i]-m[0],a[1]=t[3*i+1]-m[1],a[2]=t[3*i+2]-m[2],y(f,a,I),r.halfSize[0]=Math.max(r.halfSize[0],Math.abs(f[0])),r.halfSize[1]=Math.max(r.halfSize[1],Math.abs(f[1])),r.halfSize[2]=Math.max(r.halfSize[2],Math.abs(f[2])),s[3*i]=a[0],s[3*i+1]=a[1],s[3*i+2]=a[2];return s}_applyElevationOffsetInPlace(t,o,r){if(r!==0)for(let e=0;e<o;e++)t[3*e+2]+=r}}const I=d();function lt(){return new z}export{lt as default};
