import{r as v,t as g}from"./typedArrayUtil-a8b5b3e9.js";import{a as z,$ as G,L as S,E as Y}from"./unitUtils-47abac71.js";import{e as k}from"./mat3f64-c6305894.js";import{P as C,h as O,u as V,C as Z,B as D,i as H}from"./mat4-44a0988f.js";import{e as y,o as J}from"./mat4f64-1e28eae0.js";import{g as P}from"./mat3-3fc68e72.js";import{Z as B,x as U}from"./projection-d7b57a6c.js";import{e as u,y as f,n as W,l as K}from"./cast-7928d7aa.js";import"./ensureType-cf29afa9.js";import{v as Q}from"./quat-5b263584.js";import{e as X}from"./quatf64-7fd38d64.js";import{O as E,F as tt}from"./vec3-a020a6f6.js";import{n as b,r as rt,t as T}from"./vec3f64-2f9cef06.js";import{w as nt}from"./Extent-69509002.js";import{a as N,x as ot,g as et,O as it,h as at,L as lt,M as st,j as pt,k as ct,R as ut,v as ft,V as gt}from"./projection-aa2a8986.js";import{T as m,i as h}from"./BufferView-646ba1de.js";import{t as A,e as mt,r as $}from"./vec33-ce3aa99b.js";var M;let c=M=class extends K{constructor(t){super(t),this.origin=b(),this.translation=b(),this.rotation=N(),this.scale=rt(1,1,1),this.geographic=!0}get localMatrix(){const t=y();return Q(L,et(this.rotation),ot(this.rotation)),C(t,L,this.translation,this.scale),t}get localMatrixInverse(){return O(y(),this.localMatrix)}applyLocal(t,r){return E(r,t,this.localMatrix)}applyLocalInverse(t,r){return E(r,t,this.localMatrixInverse)}project(t,r){const n=new Float64Array(t.length),o=m.fromTypedArray(n),e=m.fromTypedArray(t);if(this.geographic){const l=z(r),p=y();return B(r,this.origin,p,l),V(p,p,this.localMatrix),A(o,e,p),U(n,l,0,n,r,0,n.length/3),n}const{localMatrix:i,origin:a}=this;Z(i,J)?mt(o,e):A(o,e,i);for(let l=0;l<n.length;l+=3)n[l+0]+=a[0],n[l+1]+=a[1],n[l+2]+=a[2];return n}getOriginPoint(t){const[r,n,o]=this.origin;return new nt({x:r,y:n,z:o,spatialReference:t})}equals(t){return v(t)&&this.geographic===t.geographic&&tt(this.origin,t.origin)&&D(this.localMatrix,t.localMatrix)}clone(){const t={origin:T(this.origin),translation:T(this.translation),rotation:N(this.rotation),scale:T(this.scale),geographic:this.geographic};return new M(t)}};u([f({type:[Number],nonNullable:!0,json:{write:!0}})],c.prototype,"origin",void 0),u([f({type:[Number],nonNullable:!0,json:{write:!0}})],c.prototype,"translation",void 0),u([f({type:[Number],nonNullable:!0,json:{write:!0}})],c.prototype,"rotation",void 0),u([f({type:[Number],nonNullable:!0,json:{write:!0}})],c.prototype,"scale",void 0),u([f({type:Boolean,nonNullable:!0,json:{write:!0}})],c.prototype,"geographic",void 0),u([f()],c.prototype,"localMatrix",null),u([f()],c.prototype,"localMatrixInverse",null),c=M=u([W("esri.geometry.support.MeshTransform")],c);const L=X(),ht=c;function x(t,r){return t.isGeographic||t.isWebMercator&&((r==null?void 0:r.geographic)??!0)}function j(t,r,n){return x(r.spatialReference,n)?xt(t,r,n):$t(t,r,n)}function yt(t,r,n){const{position:o,normal:e,tangent:i}=t;if(g(r))return{position:o,normal:e,tangent:i};const a=r.localMatrix;return j({position:ut(o,new Float64Array(o.length),a),normal:v(e)?ft(e,new Float32Array(e.length),a):null,tangent:v(i)?gt(i,new Float32Array(i.length),a):null},r.getOriginPoint(n),{geographic:r.geographic})}function Zt(t,r,n){if(n!=null&&n.useTransform){const{position:o,normal:e,tangent:i}=t;return{vertexAttributes:{position:o,normal:e,tangent:i},transform:new ht({origin:[r.x,r.y,r.z??0],geographic:x(r.spatialReference,n)})}}return{vertexAttributes:j(t,r,n),transform:null}}function At(t,r,n){return x(r.spatialReference,n)?_(t,r,n):d(t,r,n)}function Dt(t,r,n,o){if(g(r))return At(t,n,o);const e=yt(t,r,n.spatialReference);return n.equals(r.getOriginPoint(n.spatialReference))?d(e,n,o):x(n.spatialReference,o)?_(e,n,o):d(e,n,o)}function $t(t,r,n){const o=new Float64Array(t.position.length),e=t.position,i=r.x,a=r.y,l=r.z||0,{horizontal:p,vertical:w}=R(n?n.unit:null,r.spatialReference);for(let s=0;s<e.length;s+=3)o[s+0]=e[s+0]*p+i,o[s+1]=e[s+1]*p+a,o[s+2]=e[s+2]*w+l;return{position:o,normal:t.normal,tangent:t.tangent}}function xt(t,r,n){const o=r.spatialReference,e=I(r,n,F),i=new Float64Array(t.position.length),a=wt(t.position,e,o,i),l=P(q,e);return{position:a,normal:Tt(a,i,t.normal,l,o),tangent:vt(a,i,t.tangent,l,o)}}function wt(t,r,n,o){A(m.fromTypedArray(o),m.fromTypedArray(t),r);const e=new Float64Array(t.length);return it(o,e,n)}function Tt(t,r,n,o,e){if(g(n))return null;const i=new Float32Array(n.length);return $(h.fromTypedArray(i),h.fromTypedArray(n),o),at(i,t,r,e,i),i}function vt(t,r,n,o,e){if(g(n))return null;const i=new Float32Array(n.length);$(h.fromTypedArray(i,4*Float32Array.BYTES_PER_ELEMENT),h.fromTypedArray(n,4*Float32Array.BYTES_PER_ELEMENT),o);for(let a=3;a<i.length;a+=4)i[a]=n[a];return lt(i,t,r,e,i),i}function d(t,r,n){const o=new Float64Array(t.position.length),e=t.position,i=r.x,a=r.y,l=r.z||0,{horizontal:p,vertical:w}=R(n?n.unit:null,r.spatialReference);for(let s=0;s<e.length;s+=3)o[s+0]=(e[s+0]-i)/p,o[s+1]=(e[s+1]-a)/p,o[s+2]=(e[s+2]-l)/w;return{position:o,normal:t.normal,tangent:t.tangent}}function _(t,r,n){const o=r.spatialReference;I(r,n,F);const e=O(Rt,F),i=new Float64Array(t.position.length),a=Mt(t.position,o,e,i),l=P(q,e);return{position:a,normal:dt(t.normal,t.position,i,o,l),tangent:Ft(t.tangent,t.position,i,o,l)}}function I(t,r,n){B(t.spatialReference,[t.x,t.y,t.z||0],n,z(t.spatialReference));const{horizontal:o,vertical:e}=R(r?r.unit:null,t.spatialReference);return H(n,n,[o,o,e]),n}function Mt(t,r,n,o){const e=st(t,r,o),i=m.fromTypedArray(e),a=new Float64Array(e.length),l=m.fromTypedArray(a);return A(l,i,n),a}function dt(t,r,n,o,e){if(g(t))return null;const i=pt(t,r,n,o,new Float32Array(t.length)),a=h.fromTypedArray(i);return $(a,a,e),i}function Ft(t,r,n,o,e){if(g(t))return null;const i=ct(t,r,n,o,new Float32Array(t.length)),a=h.fromTypedArray(i,4*Float32Array.BYTES_PER_ELEMENT);return $(a,a,e),i}function R(t,r){if(g(t))return Et;const n=r.isGeographic?1:G(r),o=r.isGeographic?1:S(r),e=Y(1,t,"meters");return{horizontal:e*n,vertical:e*o}}const F=y(),Rt=y(),q=k(),Et={horizontal:1,vertical:1};export{ht as L,Dt as M,Zt as _,At as b,yt as k,x as r,j as x};
